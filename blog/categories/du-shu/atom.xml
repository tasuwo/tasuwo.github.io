<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 読書 | tasuwo blog]]></title>
  <link href="http://tasuwo.github.io/blog/categories/du-shu/atom.xml" rel="self"/>
  <link href="http://tasuwo.github.io/"/>
  <updated>2015-03-19T13:56:56+09:00</updated>
  <id>http://tasuwo.github.io/</id>
  <author>
    <name><![CDATA[tasuwo]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[読書：伽藍とバザール]]></title>
    <link href="http://tasuwo.github.io/blog/2015/02/23/title/"/>
    <updated>2015-02-23T15:31:21+09:00</updated>
    <id>http://tasuwo.github.io/blog/2015/02/23/title</id>
    <content type="html"><![CDATA[<p>概要と気づいたことなどメモ．</p>

<!-- more -->

<h1>Motivation</h1>

<p>論文『伽藍とバザール』を読んだ．ソフトウェア工学というキーワードでネットサーフィンしたらみかけて，タイトルが気になったので．本稿はオープンソース・ムーブメントの理論的指導者，エリック・レイモンドにより書かれたもの．その概要と気づいたことなどを簡単にまとめておく．</p>

<h1>伽藍形式とバザール形式</h1>

<p><strong>伽藍形式</strong>とは，従来のソフトウェア開発手法のことを指す．特に，OSやEmacs等の大規模ソフトウェアは，少数精鋭の閉じたコミュニティで粛々と伽藍のように作成されるべき，とされていた．<br>
<strong>バザール形式</strong>とは，オープンソース開発のような自由で開けた開発を指す．高頻度のリリースを行い，任せられるものはなんでも他人に任せて，バザールのように騒々しくオープンに開発された．この形式を用いた例として，Linuxが挙げられている．<br>
  この二者のうち，後者が特に良い結果を生み出すことができる(場合もある)として紹介されている．</p>

<h1>バザール形式の利点とは?</h1>

<p>利点というか，こんな形式でも安定したシステムを作り上げることができるということ自体が驚きだという話．しかも，高品質で満足のいく品が出来上がる．では，なぜそんなことができたのだろう? 従来の開発手法との違いはどこにあったのだろう?</p>

<h1>バザール形式の成功した理由とは?</h1>

<p>バザール形式の特徴は，「分散性」と「多様性」と「集合知」であると言われている．本形式では数多くの参加者による作業分担が行われる．この場合，作業の重複が懸念されるが，高頻度のリリースによりそのリスクも削減される．<br>
経済学の用語として<strong>デルファイ効果</strong>というものが説明されていた．噛み砕くと，一人の技術者に意見を仰ぐより，同等の技術者住人から意見を聞いて，それを平均化した方が良いというもの．リーヌスも，「問題を理解してそれを直す人物は、必ずしもどころか普通は同一人物ではない。だれかが問題を見つける。そしてそれを理解するのはだれか別の人なんだ。」と言っている．人はそれぞれ異なる観点を持つため，バザール形式では参加人数が多いほどバグの発見数も増える．そして，その修正は他の誰かに任せることができる．<br>
従来の開発手法では，このようなバグの発見に少人数が何ヶ月もの時間を費やす．その結果リリースの間隔が大きくなり，その結果リリースが完璧でない場合の失望が大きい．しかし，バザール方式ではこのようなバグは深刻な問題ではない．誰かがそれを発見し，それを直すためにリリースは増え，たまにヘマがあったところで，失うものは多くない．</p>

<h1>伽藍形式との比較</h1>

<p>従来のソフトウェア開発とバザール形式を比較して，レイモンドは以下のようなことを言っている．</p>

<blockquote>
<p>オープンソースが成功した理由の一部は、その文化がプログラミング人 口のトップ 5% しか受け入れないからだ、と信じている。彼女は、残り 95% の動員を組織するのに時間を費やしている。<br>
&#8230;<br>
もし伝統的なソフト管理の唯一の機能が、一番使えないやつらを、せめて損害は出さずにトントンに持っていくくらいだとしたら、そんな仕事は何の価値もないんじゃないか</p>
</blockquote>

<p>さらに，以下のように締めくくられる．</p>

<blockquote>
<p>ぼくたちは、もっといいソフトがつくれることを示しただけじゃない。よろこびが資産であることを証明してもいるんだ。<br>
&#8230;<br>
人間は仕事をするとき、それが最適な挑戦ゾーンになっていると、いちばん嬉しい。簡単すぎて退屈でもいけないし。達成不可能なほどむずかしくてもダメだ。シヤワセなプログラマは、使いこなされていないこともなく、どうしようもない目標や、ストレスだらけのプロセスの摩擦でげんなりしていない。<br>
&#8230;<br>
オープンソースの成功のいちばんだいじな影響の一つというのは、いちばん頭のいい仕事の仕方は遊ぶことだということを教えてくれることかもしれない。</p>
</blockquote>

<p>やりたいことをやる，という当たり前のことが，結果的に製品の品質や生産性の向上につながる．<a href="http://www.lifehacker.jp/2012/08/120824google8020rule.html">Googleの20%ルールの話</a>や，少し気色が異なるけど，<a href="http://www.ted.com/talks/simon_sinek_how_great_leaders_inspire_action?language=ja">Appleのゴールデンサークルの話</a>を思い出した．<br>
これは本当に個人的な話になるけど，自分の場合は「やりたいこと」というのが今の所あまりはっきりしていないので，これは本当に大切なことなんだなぁと他人事みたいにしか思えない．</p>

<p>論文には著者の教訓が記されている．最後に，そのうちのいくつかを紹介しておく．</p>

<blockquote>
<ul>
<li>よいソフトはすべて、開発者の個人的な悩み解決から始まる。</li>
<li>まともな行動をとってれば、おもしろい問題のほうからこっちを見つけだしてくれる。</li>
<li>おもしろい問題を解決するには、まず自分にとっておもしろい問題を見つけることから始めよう。</li>
</ul>
</blockquote>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[読書：コーディングを支える技術 1〜3章]]></title>
    <link href="http://tasuwo.github.io/blog/2015/02/18/title/"/>
    <updated>2015-02-18T01:16:55+09:00</updated>
    <id>http://tasuwo.github.io/blog/2015/02/18/title</id>
    <content type="html"><![CDATA[<p>読書して，感想や得た知識をメモします．今読んでいるのは<a href="http://www.amazon.co.jp/%E3%82%B3%E3%83%BC%E3%83%87%E3%82%A3%E3%83%B3%E3%82%B0%E3%82%92%E6%94%AF%E3%81%88%E3%82%8B%E6%8A%80%E8%A1%93-%7E%E6%88%90%E3%82%8A%E7%AB%8B%E3%81%A1%E3%81%8B%E3%82%89%E5%AD%A6%E3%81%B6%E3%83%97%E3%83%AD%E3%82%B0%E3%83%A9%E3%83%9F%E3%83%B3%E3%82%B0%E4%BD%9C%E6%B3%95-WEB-PRESS-plus/dp/477415654X">この本</a>です．</p>

<!-- more -->

<h1>はじめに</h1>

<p>大学の講義で，とんでもなく実装能力の高い後輩に刺激されて，とにかく勉強しなきゃと思って購入した本．特に，言語間の違いっていうのがよくわかっていなかった．各言語の設計思想ってどう違うの，とか，そもそもプログラミング言語ってどういう風に発達してきたの，とか，そういう部分を学びたいと思っていたら目に付いた．</p>

<p>本著書で学んだポイントをメモしておく．</p>

<h2>言語の学び方</h2>

<ul>
<li>何が言語間で共通しているのか？</li>
<li>何が特定言語におけるローカルルールなのか？</li>
</ul>

<p>(例)<br>
C言語では<strong>0が偽</strong>でその他が真<br>
Rubyでは<strong>false，nilが偽</strong>でその他が真</p>

<ul>
<li>言語設計者が何を解決したかったのか？</li>
<li>その言語がどのような背景から生まれたのか？</li>
</ul>

<p>多くの言語の比較，言語の歴史・理由を調べることで，言語が変わっても通用する理解力を養うべき．</p>

<h2>プログラミング言語の存在意義</h2>

<p>プログラミング言語は人間が楽をするために存在する．しかし，何を「楽」だと考えるかは人により異なる．</p>

<ul>
<li>プログラマの三大美徳

<ul>
<li>無精：将来も含めて一番楽な方法を選ぶ</li>
<li>短気</li>
<li>傲慢</li>
</ul></li>
</ul>

<h2>各言語の設計思想や方針まとめ</h2>

<h3>FORTH，Lisp，FORTLAN</h3>

<ul>
<li><p>FORTH，Lisp</p>

<ul>
<li>ルールの少なさ，シンプルさを求めた</li>
<li>しかし，括弧が多かったり前置・後置記法だったりで扱いづらい</li>
</ul></li>
<li><p>FORTLAN(Formula Translating System)</p>

<ul>
<li>中置記法で数式を記述できる</li>
<li>プログラマが慣れた方法で数式を記述できるように</li>
<li>FORTH，Lispよりもつっつきやすい</li>
</ul></li>
</ul>

<h3>C++，Scheme，Python</h3>

<ul>
<li><p>C++</p>

<ul>
<li>コードの高速さを重視</li>
<li>しかし，言語仕様は複雑</li>
</ul></li>
<li><p>Scheme</p>

<ul>
<li>言語仕様を把握する楽さを重視</li>
<li>しかし，構文が括弧だらけで抵抗がある</li>
</ul></li>
<li><p>Python</p>

<ul>
<li>他人の書いたコードの可読性を重視</li>
<li>しかし，早くもないし，言語仕様も特にコンパクトではない</li>
</ul></li>
</ul>

<h3>その他</h3>

<ul>
<li><p>Perl(practical extraction and report language)</p>

<ul>
<li>レポート作成を楽にできるように設計された</li>
</ul></li>
<li><p>PHP</p>

<ul>
<li>Webサービスを書くことが楽</li>
</ul></li>
<li><p>Haskell，OCaml (ML系言語)</p>

<ul>
<li>言語処理系を書くことが楽</li>
</ul></li>
</ul>

<h1>感想</h1>

<p>できる人からすれば当たり前のことかもしれないが，勉強になる．ずっと積んでいたし，他に読みたい本もあるので，一週間程度で読み切ることを目標にする．</p>
]]></content>
  </entry>
  
</feed>
