---
layout: post
title: "Gitの基礎知識をまとめたよ"
date: 2015-03-19 02:02:03 +0900
comments: true
categories: git
---

##Gitについてまとめる

GitHubを本格的に利用し始めたので．
基本的な知識は，[公式ドキュメント](http://git-scm.com/book/ja/v1/使い始める)を参照すれば身につくと思う．今回は必要最低限の知識をメモしておく．飽くまで自分用メモ．

<!-- more -->

Gitって何？というのは省略する．途中，よく使うコマンドをいくつかあげるけど，まずは読み飛ばして後から確認したほうがいいかもしれない．

#1. はじめようGit

Gitのはじめ方は二種類ある．

1. ローカルのディレクトリにGitを導入する
2. サーバに公開されているGitプロジェクトを導入する

それぞれ以下のコマンドを用いる．

1. `git init`
    * `.git`ディレクトリを生成する
    * リポジトリに必要な全てのファイルがその中に格納される
    * Gitディレクトリ，ステージングエリアが準備される
2. `git clone [url]`
    * 既存のGitリポジトリのコピーを取得する
    * サーバが保持しているデータをほぼ全てコピーする

`2.`はひとまずおいておく．`1.`の話をしていきます．

#2. Gitでずばりやることとは

Git は3つのデータ領域から構成される．

* **作業ディレクトリ**(ワークツリー)
    * 作業ファイルなどを保持しているディレクトリ
* **ステージングエリア**(インデックス)
    * 次のコミットに何が含まれるかに関しての情報を蓄えたファイル
    * Gitディレクトリに含まれる
* **Gitディレクトリ**
    * プロジェクトのためのメタデータとオブジェクトのデータベースがある所

フォルダ構成のイメージは↓こんなかんじ．

```
root          ;; 作業ディレクトリ
├ test.txt    ;; 作業ファイル
└ .git        ;; Gitディレクトリ
　├ index     ;; ステージング・エリア
　├ config
　...
```

`root`ディレクトリで`git init`を実行すると，上記のような`.git`フォルダが作成されて，3つの領域が準備される，という仕組み．

ここで，作業ディレクトリはわかるけれど，ステージングエリアとGitディレクトリは一体何なのか．
Gitはバージョン管理システムだから，当然システムの状態を時系列順に保持しておく必要がある．その保存のための場所が**Gitディレクトリ**である．
ただ，作業が一区切りついた時に，ファイルA の変更は保存しておきたいけど，ファイルB の変更はまだ保存しなくていいな...なんてことがあると思う．こういう時のための準備用の領域として用意されてるのが**ステージングエリア**である．
作業して色々なファイルを変更した後，ステージングエリアにどのファイルの変更内容を保存するか通知しておき，それを元にGitディレクトリに変更内容を保存する，という流れ．箇条書きにすると↓のようなかんじ．

1. **作業ディレクトリ**で作業して，一区切りつく
2. 保存しておきたいファイルを**ステージングエリア**に通知する
3. **ステージングエリア**を元に**Gitディレクトリ**にシステムの状態を保存する

そして，このデータ領域間のファイル操作のために`git`コマンドを用いる，というのがGitの基本．主に用いるコマンドは↓のようなかんじ．

* `git add <filepatter> ...`
    * **作業ディレクトリ**から**ステージングエリア**に対象ファイルがステージされる
    * ディレクトリは独自のツリー構造でステージされる
* `git commit -m <msg>`
    * **ステージングエリア**の内容を**Gitディレクトリ**に登録する
    * 登録すると，変更内容に対して一意のコミットIDが発行される
    * 一番最近発行されたコミットIDが`HEAD`となる
* `git reset HEAD <file>`
    * **ステージングエリア**を**Gitディレクトリ**のHEAD状態に戻す
* `git checkout -- <file>`
    * **作業ディレクトリ**を**ステージングエリア**の状態に戻す

上記のコマンドを用いた大まかな作業の流れは↓のようなかんじ

1. 作業ディレクトリで作業する
2. 作業内容を**ステージングエリア**に`git add`する
3. **ステージングエリア**の内容を**Gitディレクトリ**に`git commit`する
4. 再び作業する
5. 変更したファイルを**ステージングエリア**に`git add`する
6. **Gitディレクトリ**に`git commit`する
7. 〜繰り返し〜

#3. Gitのデータ構造に関する予備知識

説明したこと．

* 作業ディレクトリでファイルを編集する
* ステージングエリアに変更内容を準備する
* Gitディレクトリに変更内容を保存する
* これらの作業は`git`コマンドにより行う

次は，Gitがどういう仕組みでバージョン管理を行っているのかについて説明する．一口にバージョン管理とは言っても，ファイルの変更履歴の格納の仕方には色々ある．一般的なVCSは，各ファイルの基本バージョンからの変更・差分を時系列順に管理すると思う．

↓イメージ

|Version1|Version2|Version3|Version4|Version5|
|:---:|:---:|:---:|:---:|:---:|
|file A|差分1|→|差分2|→|
|file B|→|→|差分1|差分2|
|file C|差分1|差分2|→|差分3|

しかし，Gitの場合はデータをスナップショットの集合として考える．

* スナップショットって何だよ...
	* つまり**その時点のファイル丸ごと**です
	* 例えば，以下のような 1〜1000000 を記述したファイルがあったとする  
`1 2 3 ... 1000000`
	* これをGitディレクトリに commit したとする
	* その後，以下のように内容を変更したとする  
`1 2 3 ... 1000000 1000001`
	* これをGitディレクトリに commit した場合，どのようなデータがGitディレクトリに格納されるか？
	* 一般的なVCSなら，`1000001`の箇所を**差分として保持**する
	* 一方，Gitは 1〜1000000 を記述したファイルと 1〜1000001 を記述した**両方のファイルを保持**する

* それってリポジトリが肥大化しない？
	* 画像，映像等のメディアファイルを扱っているとやばいそうです
	* `git media`とか`git gc`とか，色々対策方法はあるようです
		* [もう巨大なデータをgitignoreしなくていい！ ~git-mediaの使い方~](http://endorno.github.io/blog/2013/10/06/how-to-use-git-media/)
		* [肥大化したGitリポジトリにおいて歴史の粒度を落とさずにサイズを減らすには](http://ja.stackoverflow.com/questions/2546/肥大化したgitリポジトリにおいて歴史の粒度を落とさずにサイズを減らすには)

コミット時に全てのファイルの状態のスナップショットをとり，そのスナップショットへの参照を格納する．ファイルに変更がない場合は，既に格納してある以前の同一ファイルへのリンクを格納する．

↓イメージ(括弧で囲んでいる場所は，過去のオブジェクトを参照している)

|Version1|Version2|Version3|Version4|Version5|
|:---:|:---:|:---:|:---:|:---:|
|A|A1|(A1)|A2|(A2)|
|B|(B)|(B)|B1|B2|
|C|C1|C2|(C2)|C3|

また，Gitのデータはすべて，格納される前にチェックサムが取られる．

* チェックサムって何だよ...  
	* 誤り検出のためのものです
	* データの転送中に情報を失う，もしくは壊れたファイルを取得した場合にGitが検知できるようにするためのものです
	* とりあえず，各ディレクトリやファイルに対する**一意の識別子**を算出している，と思っておけば良い

Gitがチェックサムに用いる機構は**SHA-1ハッシュ**と呼ばれる．16進数の文字で構成された40文字の文字列で，ファイルの内容もしくはGit内のディレクトリ構造を元に計算される．
↓みたいな．

```
24b9da6552252987aa493b52f8696cd6d3b00373
```


#4. Gitディレクトリに格納されているcommitオブジェクトとは

説明したこと．

* Gitは差分ではなく，スナップショット(ファイルまるごと)をGitディレクトリに保持している
* Gitディレクトリで扱う各データからは，チェックサムという一意の識別子が算出され，利用される

スナップショットってどうなっているのか？チェックサムってどうやって使っているのか？について説明する．
`git commit`を実行すると，ステージングエリアの情報を元にGitディレクトリにシステムの状態が保存される．この時の具体的な処理が↓のようなかんじ．

1. 全てのディレクトリ，ファイルのチェックサムを計算する
2. 各ファイルの中身を表す**blobオブジェクト**，ディレクトリ構成に加え，blobオブジェクトとファイル名の対応関係を表す**treeオブジェクト**を作成する
3. メタデータとtreeオブジェクトへのポインタを含んだ**commitオブジェクト**を作成する

例えば，`fileA`，`fileB`，`fileC`をcommitしたとする．

```bash
$ git add fileA fileB fileC
$ git commit -m 'initial commit of my project'
```

すると，以下のような5つのオブジェクトが作成される．

```
 98ca9...           92ec2..             5d1d3..
|commit         |  |tree            |  |blob       |
-----------------  ------------------  -------------
|tree    |92ec2 |  |blob|5b1d3|fileA|  |fileAの内容 |
|author  |tasuwo|  |blob|911e7|fileB|
|comitter|tasuwo|  |blob|cda0a|fileC|  911e7..
                                       |blob       |
                                       -------------
                                       |fileBの内容 |
                                       
                                       cda0a..
                                       |blob       |
                                       -------------
                                       |fileCの内容 |

```

各テーブルの上部にある`98ca9..`とか`92ec2..`とかがチェックサム．これが各オブジェクトの一意の識別子になる．今回は3つのファイルをcommitしたので，各ファイルに対応する3つの**blobオブジェクト**が作成される．さらに，それをまとめた**treeオブジェクト**が作成され，treeオブジェクトへのポインタと，著者やコミッターといったメタデータを保持した**commitオブジェクト**が作成される．

commitを重ねると，commitオブジェクトは前回のcommitオブジェクトへのポインタを保持するようになる(下図において，commitは左から時系列順)．

```
 98ca9..       34ac2..         f30ab..
|commit    |  |commit      |  |commit      |
------------  --------------  --------------
|...       |  |parent|98ca9|  |parent|34ac2|
```

#5. ブランチ

説明したこと．

* `git commit`すると，その時のシステムの状態がGitディレクトリに保存される
	* 各ファイルの内容は**blobオブジェクト**として保持される
	* blobオブジェクトとファイル名の関係，ディレクトリ構成は**treeオブジェクト**として保持される
	* treeオブジェクトとメタデータは**commitオブジェクト**として保持される
		* commitオブジェクトを参照すれば，1回の commit における全てのデータにアクセスできる
* commitオブジェクトは直前のcommitオブジェクトへのポインタを保持する
	* commitオブジェクトは時系列順に数珠繋ぎになっている

プロジェクトが進み，commit が重なるにつれて commitオブジェクト は増えて行く．しかし，保存するだけでは意味がない．バージョン管理システムなのだから，過去・現在のcommitオブジェクト間を行ったり来たりできる必要がある．しかし，そのためには特定のcommitオブジェクトを指定する仕組みが必要になる．そのために用意されているポインタが**ブランチ**である．
各commitオブジェクトはチェックサムで一意に識別できる．そのため，**ブランチ**は特定のコミットを指すチェックサムだけを記録したシンプルなファイルである．
プロジェクトを進める上で必要不可欠なブランチが1つある．それは，自分の作業している現在位置を示すブランチである．Git 開始時のデフォルトでは，この役割を担う`master`ブランチが用意されている．
また，ブランチは複数作成できる．しかしその場合，現在位置を示すブランチがどれなのかわからなくなってしまう．そこで，自分が今現在作業しているブランチを指し示す**HEAD**という特別ポインタが用意されている．HEADとHEADで示されたブランチは，commitにあわせて自動的に指し示す先が変化する．

`master`ブランチを使っていて，3回ほどcommitした場合のポインタの状態は↓のようなかんじ(commitは左から時系列順)．

```
                    HEAD
                     ↓
                   master
                     ↓
|commit| |commit| |commit|
```

ブランチ操作のための`git`コマンドとしては↓のようなものがある．

* `git branch <new_branch>[<start_point>]`
    * ブランチを作成する
    * **Gitディレクトリ**では，ブランチが出来る(HEADの位置は変わらない)
    * **ステージングエリア**では，何も起こらない
* `git checkout <branch>`
    * ブランチを切り替える
    * **Gitディレクトリ**では，HEADの位置が変わる
    * **ステージングエリア**では，HEADに合わせて内容が復元される
* `git merge <branch>`
    * ブランチをマージする
    * **Gitディレクトリ**では，２つのブランチをマージしたcommitが発行される
        * 新たなcommitは，マージ元の2つのcommitを親とする
    * **ステージングエリア**では，結合したブランチの変更内容が反映される

#6. リモートでの作業

説明したこと．

* commitオブジェクトは**ブランチ**によって指定できる
* 現在作業しているブランチは**HEAD**によって示される

最後にリモートリポジトリとの操作についてまとめる．
Gitはローカルでの操作だけでなく，リモートリポジトリから作業環境をひっぱってきたり，逆にローカルの編集内容をリモートに反映させたりできる．リモートリポジトリからデータを引っ張ってくることを**クローン**という．一番最初に説明した，Git を導入する2つの方法の内の2つ目である．
クローンは以下のように行う．

```bash
$ git clone git://github.com/schacon/grit.git mygrit
```

上記コマンドは，`github.com/schacon/grit.git`からデータを引っ張ってきてディレクトリ`mygrit`に格納する．

また，プロジェクトを進めていく上で，リモートサーバ(上記の例で言うなら`github.com/schacon/grit.git`)とデータのやり取りを頻繁に行う．しかし，1つのプロジェクトに対して1つのリモートサーバとは限らない．

例えば，本ブログはその雛形として`Octopress`というプロジェクトをcloneしている．しかし，記事などのデータの送信先は自分のリポジトリである．なので，

* ブログの雛形を引っ張ってきたリポジトリ
* 自分のブログを公開するためのリポジトリ

の２つのリモートリポジトリとやり取りを行っている．

だからどうなのだ，というと，つまり，

* プロジェクトを進めていく上では，**複数のリモートリポジトリとやりとりする**可能性があって，
* その時に各リモートリポジトリを一々**URLで指定するのは面倒**だ

ということ．
なので，リモートリポジトリには名前をつけることができる．ちなみに，プロジェクトをクローンした場合は，クローン元のサーバには`origin`という名前がデフォルトでつけられる．

設定されたリモートサーバはコマンド`git remote`で確認できる．`-v`オプションを指定すると，名前に対応するURLを表示する．

```
$ cd mygrit
$ git remote
origin

$ git -v remote
origin  git://github.com/schacon/grit.git (fetch)
origin  git://github.com/schacon/grit.git (push)
```

その他，よく使うコマンドは↓みたいなかんじ．

* `git remote add [shortname] [url]`
    * リモートリポジトリの追加
* `git fetch [remote-name]`
    * リモートプロジェクトの中から作業ディレクトリにデータを引き出す
    * ローカルの環境でマージされたり，作業内容を書き換えることはないため，自分でマージをする必要がある．
* `git push [remote-name] [branch-name]`
    * 指定サーバにプロジェクトをプッシュする
    * `git push origin master`
* `git remote rename`
    * リモートを参照する名前を変更できる
* `git remote rm`
    * リモートの山椒を削除する
    * サーバが移動したとか，特定のミラーを使わなくなったとか，プロジェクトからメンバーが抜けたとか

#7. まとめ

Git の基礎知識についてまとめた．

* 作業ディレクトリで作業して，ステージングエリアに変更内容を準備(`add`)して，Gitディレクトリに保存(`commit`)する
* Gitディレクトリには commitオブジェクト が時系列順に保存される
	* 特定の commitオブジェクト をブランチで指定できる
	* デフォルトでは`master`ブランチが用意される
	* 現在作業しているブランチは`HEAD`で示される
* リモートリポジトリとやりとりする際，やりとり先のサーバには名前をつける
	* デフォルトでは`origin`という名前がつく

これらの知識を踏まえれば，様々なページで説明されているgitの関連知識やコマンドが理解しやすくなる...と思う．説明がド下手なので，この記事は何回も修正することになることが予想される．

>[公式](http://git-scm.com/book/ja/v1/使い始める)
>[Gitレポジトリはパッチの集積ではなくてスナップショットの集積である。](http://dqn.sakusakutto.jp/2013/09/git_patch_snapshot.html)
>[アリスとボブになりきってgitをちゃんと理解したい！](http://d.hatena.ne.jp/zariganitosh/20080905/1220621182)
>[git push の反対は git pull ではない](http://qiita.com/usamik26/items/28be7d2c221a7a53c2c3)
>[git fetchの理解からgit mergeとpullの役割](http://qiita.com/osamu1203/items/cb94ef9da02e1ec3e921)
